### DOCX to HTML Conversion

- [ ] Create `server/src/parser/docxToHtml.ts`:
  ```typescript
  // server/src/parser/docxToHtml.ts
  import mammoth from 'mammoth';
  import logger from '../../utils/logger'; // Assuming logger from Sprint 0

  export async function convertDocxToHtml(filePathOrBuffer: string | ArrayBuffer): Promise<string> {
    try {
      const result = await mammoth.convertToHtml(
        typeof filePathOrBuffer === 'string' ? { path: filePathOrBuffer } : { buffer: filePathOrBuffer }
      );
      logger.info(`Successfully converted DOCX to HTML. Length: ${result.value.length}`);
      // Optional: Log messages from Mammoth if any
      if (result.messages && result.messages.length > 0) {
        result.messages.forEach(message => {
          logger.warn(`Mammoth message (${message.type}): ${message.message}`);
        });
      }
      return result.value; // The HTML content
    } catch (error) {
      logger.error('Error converting DOCX to HTML:', error);
      throw new Error('Failed to convert DOCX to HTML.');
    }
  }
  ```

- [ ] Create a basic test file `server/src/parser/__tests__/docxToHtml.test.ts`:
  ```typescript
  // server/src/parser/__tests__/docxToHtml.test.ts
  import path from 'path';
  import fs from 'fs/promises';
  import { convertDocxToHtml } from '../docxToHtml';

  // Mock logger to prevent console output during tests
  jest.mock('../../utils/logger', () => ({
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
  }));

  describe('convertDocxToHtml', () => {
    const fixturesDir = path.join(__dirname, 'fixtures');
    const testDocxPath = path.join(fixturesDir, 'sample_career.docx');
    const nonExistentPath = path.join(fixturesDir, 'non_existent.docx');

    // Before running tests, create a dummy DOCX file if it doesn't exist
    // In a real scenario, this would be a small, valid DOCX file.
    // For this test, we'll just ensure the directory exists and create an empty file
    // to simulate its presence, as mammoth.js handles actual parsing.
    beforeAll(async () => {
      try {
        await fs.mkdir(fixturesDir, { recursive: true });
        // Create a tiny, valid (but empty content) DOCX file for testing path resolution
        // This is a simplified representation. A real test file would be better.
        // Base64 for a minimal DOCX: PK... (very simple structure)
        const minimalDocxBase64 = 'UEsDBBQAAAAIAAgAAAAAAAABAAAAAAAAAAAAAAAABgAAAF9yZWxzLy5yZWxzUEsDBBQAAAAIAAgAAAAAAAABAAAAAAAAAAAAAAAACQAAAFtDb250ZW50X1R5cGVzXS54bWxQSwMEFAAAAAgACAAAAAAAAAEAAAAAAAAAAAAAAAAMAAAAZG9jUHJvcHMvYXBwLnhtbFBLAwQUAAAACAAIAAAAAAAAAYAAAAAAAAAAAAAAABAAAABkb2NQcm9wcy9jb3JlLnhtbFBLAwQUAAAACAAIAAAAAAAAAYAAAAAAAAAAAAAAABMAAABkb2NQcm9wcy9jdXN0b20ueG1sUEsDBBQAAAAIAAgAAAAAAAABAAAAAAAAAAAAAAAADwAAAHdvcmQvX3JlbHMvZG9jdW1lbnQueG1sLnJlbHNQSwMEFAAAAAgACAAAAAAAAAEAAAAAAAAAAAAAAAATAAAAd29yZC9kb2N1bWVudC54bWxQSwMEFAAAAAgACAAAAAAAAAEAAAAAAAAAAAAAAAARAAAAd29yZC9mb250VGFibGUueG1sUEsDBBQAAAAIAAgAAAAAAAABAAAAAAAAAAAAAAAADgAAAHdvcmQvc2V0dGluZ3MueG1sUEsDBBQAAAAIAAgAAAAAAAABAAAAAAAAAAAAAAAADQAAAHdvcmQvc3R5bGVzLnhtbFBLAwQUAAAACAAIAAAAAAAAAYAAAAAAAAAAAAAAABIAAAB3b3JkL3RoZW1lL3RoZW1lMS54bWxQSwMEFAAAAAgACAAAAAAAAAEAAAAAAAAAAAAAAAATAAAAd29yZC93ZWJTZXR0aW5ncy54bWxQSwUGAAAAAAwADAAyBAAAzgUAAAAA';
        await fs.writeFile(testDocxPath, Buffer.from(minimalDocxBase64, 'base64'));
      } catch (err) {
        console.error('Failed to set up test fixtures:', err);
      }
    });

    afterAll(async () => {
      try {
        // Clean up the dummy file
        // await fs.unlink(testDocxPath); // Keep for manual inspection if needed
      } catch (err) {
        // console.error('Failed to clean up test fixtures:', err);
      }
    });

    it('should convert a DOCX file from a path to HTML', async () => {
      const html = await convertDocxToHtml(testDocxPath);
      expect(html).toBeDefined();
      expect(typeof html).toBe('string');
      // Basic check: HTML usually starts with <p> or <h1> etc. if content exists
      // For a truly minimal DOCX, it might be empty or just basic tags.
      // This assertion depends on the content of your `sample_career.docx`
      // For the minimal base64, it will likely be an empty string or very basic structure.
      // expect(html).toContain('<p>'); // Adjust based on actual minimal output
    });

    it('should convert a DOCX file from a buffer to HTML', async () => {
      const buffer = await fs.readFile(testDocxPath);
      const html = await convertDocxToHtml(buffer);
      expect(html).toBeDefined();
      expect(typeof html).toBe('string');
      // expect(html).toContain('<p>'); // Adjust based on actual minimal output
    });

    it('should throw an error if the file path does not exist', async () => {
      await expect(convertDocxToHtml(nonExistentPath)).rejects.toThrow(
        'Failed to convert DOCX to HTML.'
      );
    });

    it('should throw an error for an invalid buffer (e.g., empty or corrupted)', async () => {
      const invalidBuffer = Buffer.from('this is not a docx file');
      await expect(convertDocxToHtml(invalidBuffer)).rejects.toThrow(
        'Failed to convert DOCX to HTML.'
      );
    });
  });
  ```

- [ ] Create a placeholder `sample_career.docx` in `server/src/parser/__tests__/fixtures/`. This should be a very simple DOCX file with a few lines of text, perhaps a heading and a paragraph, for initial testing. (Manual creation or use a tiny base64 encoded one in the test setup). The test setup above includes a minimal base64 DOCX.